<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Articles on gingerBill</title>
    <link>/article/</link>
    <description>Recent content in Articles on gingerBill</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Wed, 05 Sep 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/article/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Exceptions - And Why Odin Will Never Have Them</title>
      <link>/article/2018/09/05/exceptions-and-why-odin-will-never-have-them/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/article/2018/09/05/exceptions-and-why-odin-will-never-have-them/</guid>
      <description>Article was originally posted here: https://odin.handmade.network/blogs/p/3372-exceptions_-_and_why_odin_will_never_have_them
Original Comments:
 https://github.com/odin-lang/Odin/issues/256#issuecomment-418073701 https://github.com/odin-lang/Odin/issues/256#issuecomment-418289626  
There will never be software exceptions in the traditional sense. I hate the entire philosophy behind the concept. Go does have exceptions with the defer, panic, recover approach. They are weird on purpose. Odin could have something similar for exceptional cases. You can the exact same semantics as a try except block by using a switch in statement.</description>
    </item>
    
    <item>
      <title>On the Aesthetics of the Syntax of Declarations</title>
      <link>/article/2018/03/12/on-the-aesthetics-of-the-syntax-of-declarations/</link>
      <pubDate>Mon, 12 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/article/2018/03/12/on-the-aesthetics-of-the-syntax-of-declarations/</guid>
      <description>Article was originally posted here: https://odin.handmade.network/blogs/p/2994-on_the_aesthetics_of_the_syntax_of_declarations
n.b. This is a philosophical article and not a technical article. There are no correct answers to the questions that I will pose &amp;ndash; only compromises.
I&amp;rsquo;m considering what the &amp;ldquo;best&amp;rdquo; declaration syntax would be. Historically, there have been two categories: which I will call qualifier-focused and type-focused. An example of qualifier-focused would be the Pascal family. An example of type-focused would be the C family.</description>
    </item>
    
    <item>
      <title>The Metaprogramming Dilemma</title>
      <link>/article/2016/12/01/the-metaprogramming-dilemma/</link>
      <pubDate>Thu, 01 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/article/2016/12/01/the-metaprogramming-dilemma/</guid>
      <description>Article was originally posted here: https://odin.handmade.network/blogs/p/1723-the_metaprogramming_dilemma
Designing this language has been difficult but fun. Two of the original goals of this language were simplicity and metaprogramming however, these together could be an oxymoron. But before I explain why, I first need to explain what I mean by &amp;ldquo;metaprogramming&amp;rdquo;.
Metaprogramming is an &amp;ldquo;art&amp;rdquo; of writing programs to treats other programs as their data. This means that a program could generate, read, analyse, and transform code or even itself to achieve a certain solution.</description>
    </item>
    
    <item>
      <title>A Defer Statement For C&#43;&#43;11</title>
      <link>/article/2015/08/19/defer-in-cpp/</link>
      <pubDate>Wed, 19 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/article/2015/08/19/defer-in-cpp/</guid>
      <description>One of my favourite things about Go is the defer statement. The defer statement pushes a function call onto a list; the list of saved calls in called when the function returns.
Imitating this is C++ is impossible. Instead of calling when the function calls, you can call at the end of scope; this is a better approach for C++. This is similar to how D has scope(exit).
C++11 Implementation template &amp;lt;typename F&amp;gt; struct privDefer { F f; privDefer(F f) : f(f) {} ~privDefer() { f(); } }; template &amp;lt;typename F&amp;gt; privDefer&amp;lt;F&amp;gt; defer_func(F f) { return privDefer&amp;lt;F&amp;gt;(f); } #define DEFER_1(x, y) x##y #define DEFER_2(x, y) DEFER_1(x, y) #define DEFER_3(x) DEFER_2(x, __COUNTER__) #define defer(code) auto DEFER_3(_defer_) = defer_func([&amp;amp;](){code;})  Explanation One of the most common examples for this in Go is files.</description>
    </item>
    
  </channel>
</rss>