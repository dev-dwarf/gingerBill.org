<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on gingerBill</title>
    <link>http://www.gingerbill.org/topics/programming/</link>
    <description>Recent content in Programming on gingerBill</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <copyright>Copyright (c) 2007 - 2015, Ginger Bill</copyright>
    <lastBuildDate>Wed, 19 Aug 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.gingerbill.org/topics/programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A Defer Statement for C&#43;&#43;11</title>
      <link>http://www.gingerbill.org/post/defer-in-c&#43;&#43;11/</link>
      <pubDate>Wed, 19 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://www.gingerbill.org/post/defer-in-c&#43;&#43;11/</guid>
      <description>

&lt;p&gt;One of my favourite things about &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; is the &lt;code&gt;defer&lt;/code&gt; statement. The &lt;code&gt;defer&lt;/code&gt; statement pushes a function call onto a list; the list of saved calls in called when the function returns.&lt;/p&gt;

&lt;p&gt;Imitating this is C++ is impossible. Instead of calling when the function calls, you can call at the end of scope; this is a better approach for C++. This is similar to how &lt;a href=&#34;http://dlang.org/statement.html#ScopeGuardStatement&#34;&gt;D has scope(exit)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;c-11-implementation:a3b5b1ab976249e2a6561d9845c75b7c&#34;&gt;C++11 Implementation&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// This code requires C++11 features such as move semantics
#include &amp;lt;functional&amp;gt;

namespace Impl
{
template &amp;lt;typename Func&amp;gt;
struct Defer
{
    Func func;
    Defer(Func&amp;amp;&amp;amp; func)
    : func(std::forward&amp;lt;Func&amp;gt;(func))
    {
    }

    ~Defer()
    {
        func();
    }
};

template &amp;lt;typename Func&amp;gt;
Defer&amp;lt;Func&amp;gt; deferFunc(Func&amp;amp;&amp;amp; func)
{
    return Defer&amp;lt;Func&amp;gt;(std::forward&amp;lt;Func&amp;gt;(func));
}

#define DEFER_1(x, y) x##y
#define DEFER_2(x, y) DEFER_1(x, y)
#define DEFER_3(x) DEFER_2(x, __COUNTER__)
#define defer(code) auto DEFER_3(_defer_) = Impl::deferFunc([&amp;amp;](){code;});

} // namespace Impl

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;explanation:a3b5b1ab976249e2a6561d9845c75b7c&#34;&gt;Explanation&lt;/h2&gt;

&lt;p&gt;One of the most common examples for this in Go is files.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;os&amp;quot;

func someFunc() {
    file, err := os.Open(&amp;quot;filename.ext&amp;quot;, os.O_RDONLY, 0)
    if err != nil {
        // handle error
        return
    }
    defer os.Close(file)
    // Do whatever

    return // No need to close file explicitly
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In C/C++, before every return, &lt;code&gt;fclose&lt;/code&gt; must be called.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void someFunc()
{
    FILE* file = fopen(&amp;quot;filename.ext&amp;quot;, &amp;quot;rb&amp;quot;);
    if (file == nullptr)
    {
        // handle error
        return;
    }

    if (someTest)
    {
        // ...

        fclose(file); // Have to explicitly close file
        return;
    }


    fclose(file); // Have to explicit close file
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may say that RAII in C++ solves this issue but this would require a class wrapper. &lt;code&gt;defer&lt;/code&gt; allows for the same thing as RAII but without manually creating a wrapper type.&lt;/p&gt;

&lt;p&gt;Also, &lt;code&gt;defer&lt;/code&gt; conceptually links the creation with the destruction without hiding it.&lt;/p&gt;

&lt;h2 id=&#34;examples-in-c-code:a3b5b1ab976249e2a6561d9845c75b7c&#34;&gt;Examples in C++ Code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
void someFunc()
{
    FILE* file = fopen(&amp;quot;filename.ext&amp;quot;, &amp;quot;rb&amp;quot;);
    if (file == nullptr)
        return;
    defer(fclose(file));

    u8* buffer = (u8*)allocate(64 * sizeof(u8));
    if (buffer == nullptr)
        return; // fclose is called automatically
    defer(deallocate(buffer));

    defer({
        printf(&amp;quot;You can even defer &amp;quot;);
        printf(&amp;quot;an entire block too!&amp;quot;);
    });

    // Do whatever...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I use this regularly within code (especially in the &lt;a href=&#34;https://github.com/gingerBill/Dunjun&#34;&gt;Dunjun&lt;/a&gt; series). It is very useful when dealing with C code bases.&lt;/p&gt;

&lt;p&gt;There are numerous other implementations of this too and I have linked to these below.&lt;/p&gt;

&lt;h3 id=&#34;other-implementations:a3b5b1ab976249e2a6561d9845c75b7c&#34;&gt;Other Implementations&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://the-witness.net/news/2012/11/scopeexit-in-c11/&#34;&gt;Ignacio Castaño&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.korfuri.fr/post/go-defer-in-cpp/&#34;&gt;Korfuri&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://kri.gs/2013/01/20/defer-cpp/&#34;&gt;Kristoffer Grönlund&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;caveat:a3b5b1ab976249e2a6561d9845c75b7c&#34;&gt;Caveat&lt;/h2&gt;

&lt;p&gt;Because the &lt;code&gt;defer&lt;/code&gt; statement is called at the end of scope rather than function return, a Go programmer would example something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void anotherFunc()
{
    for (int i = 0; i &amp;lt; 4; i++)
        defer(printf(&amp;quot;%d &amp;quot;, i));
    printf(&amp;quot;Hello &amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to return &lt;code&gt;Hello 0 1 2 3&lt;/code&gt;. However, it will return &lt;code&gt;0 1 2 3 Hello&lt;/code&gt;. I personally prefer the scope behaviour but that is just a matter of opinion.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>