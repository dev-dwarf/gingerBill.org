<!DOCTYPE html>
<html lang="en-gb">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>The Odin Programming Language Specification - gingerBill</title>
  <link rel="stylesheet" href="/css/normalize.css" />
  <link rel="stylesheet" href="/css/style.css" />
</head>
<body>
<div class="wrapper">
<header>
  <nav>
    <h1 id="logo"><a href="/"><span class="ginger">ginger</span>Bill</a></h1>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      <li><a href="/article/">Articles</a></li>
      <li><a href="/article/index.xml">Subscribe</a></li>
    </ul>
  </nav>
</header>

<main>
<article class="article-meta">
<header>
	<h1>The Odin Programming Language Specification</h1>
	
	<div class="info">
		
		<p>
		
		</p>
	</div>
</header>


<p><strong>Warning:</strong> This is a work in progress and is subject to change.</p>

<hr />

<h2 id="introduction">Introduction</h2>

<p>This is a reference manual for the Odin programming language.</p>

<p>Odin is a general-purpose language designed for systems programming. It is a strongly typed language with manual memory managment. Programs are constructed from <em>packages</em>.</p>

<h2 id="notation">Notation</h2>

<p>The syntax is specified using Extended Backus-Naur Form (EBNF):</p>

<pre><code>Production  = production_name &quot;=&quot; [ Expression ] &quot;.&quot; .
Expression  = Alternative { &quot;|&quot; Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ &quot;…&quot; token ] | Group | Option | Repetition .
Group       = &quot;(&quot; Expression &quot;)&quot; .
Option      = &quot;[&quot; Expression &quot;]&quot; .
Repetition  = &quot;{&quot; Expression &quot;}&quot; .
</code></pre>

<p>Productions are expressions constructed from terms and the following operators, in increasing precedence:</p>

<pre><code>|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
</code></pre>

<h2 id="source-code-representation">Source code representation</h2>

<p>Source code is Unicode text encoded in UTF-8. The text is not canonicalized, so a single accented code point is distinct from the same character constructed from combining an accent and a letter; those are treated as two separate code points. In this document, the term <em>character</em> will be used to refer to a Unicode code point in the source text.</p>

<p>Each code point is distinct; there is case sensitivity.</p>

<p>Implementation restriction: A compile must disallow the NUL character (U+0000) in the source text.
Implementation restriction: A compile may ignore a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code point in the source text. A byte order mark must be disallowed anywhere else in the source text.</p>

<h3 id="characters">Characters</h3>

<p>The following terms are used to denote specific Unicode character classes:</p>

<pre><code>newline        = /* the Unicode code point U+000A */
unicode_char   = /* an arbitrary Unicode code point except newline */
unicode_letter = /* a Unicode code point classified as &quot;Letter&quot; */
unicode_digit  = /* a Unicode code point classified as &quot;Number, decimal digit&quot; */
</code></pre>

<p>In <a href="https://www.unicode.org/versions/Unicode8.0.0/">The Unicode Standard 8.0</a>, Section 4.5 &ldquo;General Category&rdquo; defines a set of character categories. Odin treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo as Unicode letters, and those in the Number category Nd as Unicode digits.</p>

<h3 id="letters-and-digits">Letters and digits</h3>

<p>The underscore character <code>_</code> (U+005F) is considered a letter.</p>

<pre><code>letter        = unicode_letter | &quot;_&quot; .
binary_digit  = &quot;0&quot; … &quot;1&quot; .
octal_digit   = &quot;0&quot; … &quot;7&quot; .
decimal_digit = &quot;0&quot; … &quot;9&quot; .
dozenal_digit = &quot;0&quot; … &quot;9&quot; | &quot;A&quot; … &quot;B&quot; | &quot;a&quot; … &quot;b&quot; .
hex_digit     = &quot;0&quot; … &quot;9&quot; | &quot;A&quot; … &quot;F&quot; | &quot;a&quot; … &quot;f&quot; .

binary_char  = binary_digit  | &quot;_&quot; .
octal_char   = octal_digit   | &quot;_&quot; .
decimal_char = decimal_digit | &quot;_&quot; .
dozenal_char = dozenal_digit | &quot;_&quot; .
hex_char     = hex_digit     | &quot;_&quot; .
</code></pre>

<h2 id="lexical-elements">Lexical elements</h2>

<h3 id="comments">Comments</h3>

<p>Comments serve as program documentation. There are three forms:</p>

<ol>
<li><em>Line comments</em> start with the character sequence <code>//</code> and stop at the end of the line</li>
<li><em>General comments</em> start with the character sequence <code>/*</code> and stop with a pairing character sequence <code>*/</code> to allow for nested general comments</li>
<li><em>Hash-bang comments</em> start with the character sequence <code>#!</code> and stop at the end of the line</li>
</ol>

<p>A comment cannot start inside a <em>rune</em> or <em>string</em> literal, or inside a line or hash-bang comment.</p>

<h3 id="tokens">Tokens</h3>

<p>Tokens form the vocabulary of the Odin language. There four classes: <em>identifiers</em>, <em>keywords</em>, <em>operators</em> and <em>punctuation</em>, and <em>literals</em>. <em>White space</em>, formed from spaces (U+0020), horizontal tabs (U+0009), carriage returns (U+000D), and new lines (U+000A), is ignored except as it separates tokens that would otherwise combine into a single token</p>

<h3 id="semicolons">Semicolons</h3>

<p>The formal grammar uses semicolons <code>;</code> as terminators. Odin programs may omit these semicolons under the following rules:</p>

<ol>
<li>followed by one of the operators and punctuation on the same line: <code>}</code>, <code>)</code></li>
<li>followed by one of the keywords on the same line: <code>else</code></li>
<li>preceded by one of the statements: block, if, when, for, switch</li>
<li>preceded by one of the declarations: package, import, foreign import, foreign block</li>
<li>the last expression in a constant value declaration is one of the expressions followed by a new line: procedure literal</li>
<li>the last expression in a constant value declaration is one of the types followed by a new line: helper type of [6], pointer type of [6], struct type, union type, enum type, bit field type</li>
</ol>

<h3 id="identifiers">Identifiers</h3>

<p>Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter.</p>

<pre><code>identifier = letter { letter | unicode_digit } .
</code></pre>

<p>Some identifiers are predeclared.</p>

<h3 id="keywords">Keywords</h3>

<p>The following keywords are reserved and may not be used as identifiers</p>

<pre><code>align_of     case        defer       enum           import    no_inline    proc       transmute    when
auto_cast    cast        distinct    fallthrough    in        notin        return     type_of
bit_field    const       do          for            inline    offset_of    size_of    typeid
bit_set      context     dynamic     foreign        macro     opaque       struct     union
break        continue    else        if             map       package      switch     using
</code></pre>

<p>Some keywords are currently not used by the language but are just reserved for future use.</p>

<h3 id="operators-and-punctuation">Operators and punctuation</h3>

<p>The following character sequences represent operators (including assignment operators) and punctuation:</p>

<pre><code>+     &amp;     +=     &amp;=     &amp;&amp;     ==    !=    (    )    #    -&gt;
-     |     -=     |=     ||     &lt;     &lt;=    [    ]    @    &lt;-
*     ~     *=     ~=     &amp;&amp;=    &gt;     &gt;=    {    }    $    =&gt;
/     &lt;&lt;    /=     &lt;&lt;=    ||=    =     ..    ,    ;    ?    ---
%     &gt;&gt;    %=     &gt;&gt;=           !           .    :
%%    &amp;~    %%=    &amp;~=
</code></pre>

<p>Implementation option: A compiler may allow the following character sequences as aliases for other operators, punctuation, and keywords:</p>

<pre><code>'≠' (U+2260) alias for '!='
'≤' (U+2260) alias for '&lt;='
'≥' (U+2260) alias for '&gt;='
'∈' (U+2260) alias for 'in'
'∉' (U+2260) alias for 'notin'
</code></pre>

<h3 id="integer-literals">Integer literals</h3>

<p>An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a specific radix: <code>0b</code> for binary, <code>0o</code> for octal, <code>0d</code> for decimal, <code>0z</code> for dozenal, or <code>0x</code> for hexadecimal. In dozenal literals, letters <code>a-b</code> and <code>A-B</code> represents values ten through eleven. In hexadecimal literals, letters <code>a-f</code> and <code>A-F</code> represents values ten through fifteen.</p>

<p>Integer literals may contain any amount of the underscore character <code>_</code> (U+005F) within the literal after the first character.</p>

<pre><code>int_lit = binary_lit | octal_lit | decimal_lit | dozenal_lit | hex_lit
binary_lit      = &quot;0b&quot;   binary_digit  { binary_char } .
octal_lit       = &quot;0o&quot;   octal_digit   { octal_char } .
decimal_lit     = [&quot;0d&quot;] decimal_digit { decimal_char } .
dozenal_lit     = &quot;0z&quot;   dozenal_digit { dozenal_char } .
hexadecimal_lit = &quot;0x&quot;   hex_digit     { hex_char } .
</code></pre>

<pre><code>42
042 // == 42
0b1001011
0o712
0d42
0z19b3
0xDeadBeef
210206826754181103207028761697008013415622289
210_206_826_754_181_103_207_028_761_697_008_013_415_622_289
</code></pre>

<h3 id="floating-point-literals">Floating-point literals</h3>

<p>A floating-point literal is a textual representation of a floating-point constant. There are two forms of floating-point literals decimal and hexadecimal. Hexadecimal floating-point literals represent the internal integer representation of the floating-point number for that platform.</p>

<pre><code>float_lit = decimal_float_lit | hexadecimal_float32_lit | hexadecimal_float64_lit .
decimal_float_lit = decimals &quot;.&quot; [decimals] [exponent] |
                    decimals exponent |
                    &quot;.&quot; decimals [exponent] .
decimals = decimal_digit { decimal_char } .
exponent = ( &quot;e&quot; | &quot;E&quot; ) [ &quot;+&quot; | &quot;-&quot; ] decimals .

hexadecimal_float32_lit = &quot;0h&quot; hex_digit hex_char hex_char hex_char
                          hex_char hex_char hex_char hex_char .
hexadecimal_float64_lit = &quot;0h&quot; hex_digit hex_char hex_char hex_char
                          hex_char hex_char hex_char hex_char
                          hex_char hex_char hex_char hex_char
                          hex_char hex_char hex_char hex_char .
</code></pre>

<pre><code>0.
0.0
42.36
042.36  // == 42.36
6.28318530718
1.e+0
1.054571800e-34
1.054_571_800e-34
1E9
.125
.12345e+5
</code></pre>

<h3 id="imaginary-literals">Imaginary literals</h3>

<p>An imaginary literal is a decimal representation of the imaginary part of a complex constant. It consists of a floating-point literal or a decimal integer followed by the lower-case letter <code>i</code>.</p>

<pre><code>imaginary_lit = (decimals | float_lit) &quot;i&quot; .
</code></pre>

<pre><code>0.i
0.0i
42.36i
042.36i  // == 42.36i
6.28318530718i
1.e+0i
1.054571800e-34i
1.054_571_800e-34i
1E9i
.125i
.12345e+5i
</code></pre>

<h3 id="rune-literals">Rune literals</h3>

<p>A rune literal represents a rune constant, an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, such as <code>'b'</code> or <code>'\t'</code>.</p>

<p>TODO:</p>

<pre><code>\a   U+0007 alert or bell
\b   U+0008 backspace
\e   U+001b escape
\f   U+000C form feed
\n   U+000A newline or line feed
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000b vertical tab
\\   U+005c backslash
\'   U+0027 single quote  (valid escape only within rune literals)
\&quot;   U+0022 double quote  (valid escape only within string literals)
</code></pre>

<pre><code>rune_lit         = &quot;'&quot; ( unicode_value | byte_value ) &quot;'&quot; .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` &quot;x&quot; hex_digit hex_digit .
little_u_value   = `\` &quot;u&quot; hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` &quot;U&quot; hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( &quot;a&quot; | &quot;b&quot; | &quot;e&quot; | f&quot; | &quot;n&quot; | &quot;r&quot; | &quot;t&quot; | &quot;v&quot; | `\` | &quot;'&quot; | `&quot;` ) .
</code></pre>

<h3 id="string-literals">String literals</h3>

<p>TODO:</p>

<pre><code>string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = &quot;`&quot; { unicode_char | newline } &quot;`&quot; .
interpreted_string_lit = `&quot;` { unicode_value | byte_value } `&quot;` .
</code></pre>

<h2 id="constants">Constants</h2>

<h2 id="variables">Variables</h2>

<h2 id="types">Types</h2>

<p>A type determines a set of values together with operations specific to those values. A type may be denoted by a <em>type name</em>, if it has one, or a specified using a <em>type literal</em>, which composing a type from other existing types.</p>

<pre><code>Type       = TypeName | TypeLit | &quot;(&quot; Type &quot;)&quot; | HelperType .
TypeName   = identifier | QualifiedIdent .
TypeLit    = ArrayType | SliceType | DynamicArrayType | StructType | UnionType |
             PointerType | ProcedureType | MapType | EnumType |
             BitSetType | BitFieldType | OpaqueType | HelperType
</code></pre>

<h3 id="boolean-types">Boolean types</h3>

<p>A boolean type represents the set of boolean truth values denoted by the predeclared constants <code>true</code> and <code>false</code>. The predeclared architecture-independent boolean types are:</p>

<pre><code>bool    1 byte boolean type

b8      8-bit  boolean type
b16     16-bit boolean type
b32     32-bit boolean type
b64     64-bit boolean type
</code></pre>

<h3 id="numeric-types">Numeric types</h3>

<p>A numeric type represents sets of integer, floating-point, or rune values. The predeclared architecture-independent numeric types are:</p>

<pre><code>u8          the set of all unsigned  8-bit integers (0 to 255)
u16         the set of all unsigned 16-bit integers (0 to 65535)
u32         the set of all unsigned 32-bit integers (0 to 4294967295)
u64         the set of all unsigned 64-bit integers (0 to 18446744073709551615)

i8          the set of all signed  8-bit integers (-128 to 127)
i16         the set of all signed 16-bit integers (-32768 to 32767)
i32         the set of all signed 32-bit integers (-2147483648 to 2147483647)
i64         the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

f32         the set of all IEEE-754 32-bit floating-point numbers
f64         the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        alias for u8
rune        the set of all Unicode code points represented by a 32-bit integer (-2147483648 to 2147483647)
</code></pre>

<p>The value of an n-bit integer is n bits wide and represented using two&rsquo;s complement arithmetic.</p>

<p>There is also a set of architecture-independent numeric types with a specified endianess:</p>

<pre><code>u16le       little endian representation of the set of all unsigned 16-bit integers (0 to 65535)
u32le       little endian representation of the set of all unsigned 32-bit integers (0 to 4294967295)
u64le       little endian representation of the set of all unsigned 64-bit integers (0 to 18446744073709551615)

i16le       little endian representation of the set of all signed 16-bit integers (-32768 to 32767)
i32le       little endian representation of the set of all signed 32-bit integers (-2147483648 to 2147483647)
i64le       little endian representation of the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

u16be       big endian representation of the set of all unsigned 16-bit integers (0 to 65535)
u32be       big endian representation of the set of all unsigned 32-bit integers (0 to 4294967295)
u64be       big endian representation of the set of all unsigned 64-bit integers (0 to 18446744073709551615)

i16be       big endian representation of the set of all signed 16-bit integers (-32768 to 32767)
i32be       big endian representation of the set of all signed 32-bit integers (-2147483648 to 2147483647)
i64be       big endian representation of the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)
</code></pre>

<p>There is also a set of predeclared numeric types with implementation-specific sizes:</p>

<pre><code>uintptr     an unsigned integer large enough to store the uninterpreted bits of a pointer value
uint        same size as uintptr
int         same size as uint
</code></pre>

<p>To avoid portability issues for all numeric types are defined types and thus distinct, except <code>byte</code> which is an alias for <code>u8</code>. Explicit conversions are required when different numeric types are mixed in an expression or assignment. For instance, <code>i64</code> and <code>int</code> are not the same type even though they may have the same size on a particular machine.</p>

<h3 id="string-types">String types</h3>

<p>A <em>string</em> type represents the set of string values. A string value is a (possibly empty) sequence of bytes. The number of bytes is called the length of the string and is a non-negative integer.</p>

<p>The predeclared strings types are:</p>

<pre><code>string
cstring
</code></pre>

<p>The length of a string <code>s</code> can be determined using the built-in procedure <code>len</code>. The length is a compile-time constant if the string is a constant. A string&rsquo;s bytes can only be accessed, for string types not derived from <code>cstring</code>, by integer indices 0 through <code>len(s)-1</code>.</p>

<h3 id="array-types">Array types</h3>

<p>An array is a numbered sequence of elements of a single type, called the element type. The number of element is a called the length of the array and is a non-negative integer.</p>

<pre><code>ArrayType   = &quot;[&quot; ArrayLength &quot;]&quot; ElementType .
ArrayLength = Expression .
ElementType = Type .
</code></pre>

<p>The length is part of the array&rsquo;s type; it must evaluate to a non-negative constant representable by a value of type <code>int</code>. The length of array <code>a</code> be determined using the built-in procedure <code>len</code>. The elements can be address by indices 0 through <code>len(a)-1</code>. Array types are always one-dimensional but may be composed to form multi-dimensional types.</p>

<pre><code>[32]byte
[2*N]union{int, string}
[42]^f32
[2][3]int
[3][3][3]f64 // same as [3]([3]([3]f64))
</code></pre>

<h3 id="slice-types">Slice types</h3>

<h3 id="dynamic-array-types">Dynamic array types</h3>

<h3 id="struct-types">Struct types</h3>

<h3 id="union-types">Union types</h3>

<h3 id="pointer-types">Pointer types</h3>

<p>TODO: <code>rawptr</code></p>

<h3 id="procedure-types">Procedure types</h3>

<h3 id="map-types">Map types</h3>

<h3 id="enum-types">Enum types</h3>

<h3 id="bit-set-types">Bit set types</h3>

<h3 id="bit-field-types">Bit field types</h3>

<h3 id="opaque-types">Opaque types</h3>

<h3 id="helper-types">Helper types</h3>

<h3 id="any-type">Any type</h3>

<h3 id="typeid">Typeid</h3>

<h3 id="other">Other</h3>

<h4 id="simd-types">SIMD types</h4>

<h2 id="properties-of-types-and-values">Properties of types and values</h2>

<h3 id="type-identity">Type identity</h3>

<h3 id="assignability">Assignability</h3>

<h3 id="representability">Representability</h3>

<h2 id="blocks">Blocks</h2>

<p>A <em>block</em> is a possibly empty sequence of declarations and statements within matching brace brackets.</p>

<pre><code>Block = &quot;{&quot; StatementList &quot;}&quot; .
StatementList = { Statement &quot;;&quot; } .
</code></pre>

<p>In addition to explicit blocks in the source text, there are implicit blocks:</p>

<ol>
<li>The <em>universal block</em> encompasses all Odin source text.</li>
<li>Each package has a <em>package block</em> containing all Odin source text for that package.</li>
<li>Each file has a <em>file block</em> containing all Odin source text in that file.</li>
<li>Each &ldquo;if&rdquo;, &ldquo;for&rdquo;, &ldquo;switch&rdquo; statement is considered to be in its own implicit block.</li>
</ol>

<p>Blocks nest and influence scoping.</p>

<h2 id="declarations-and-scope">Declarations and scope</h2>

<h3 id="label-scopes">Label scopes</h3>

<p>Labels are declared by labeled statements and used in the &ldquo;break&rdquo; and &ldquo;continue&rdquo; statements. In contrast to other identifiers, labels are not block scoped. The scope of the label is the body of the procedure in which it is declared and excludes the body of any nested procedure.</p>

<h3 id="blank-identifier">Blank identifier</h3>

<h3 id="predeclared-identifiers">Predeclared identifiers</h3>

<pre><code>Types:
    bool b8 b16 b32 b64
    byte complex64 complex128
    f32 f64
    int i8 i16 i32 i64
    i16le i32le i64le i16be i32be i64be

    uint uintptr u8 u16 u32 u64
    u16le u32le u64le u16be u32be u64be

    any rawptr

    rune string cstring

Constants:
    true false

Zero value:
    nil

Procedures:
    len cap
    complex real imag conj
    swizzle expand_to_tuple
    min max abs clamp

</code></pre>

<h2 id="expressions">Expressions</h2>

<h3 id="operators">Operators</h3>

<h4 id="operator-precedence">Operator precedence</h4>

<p>Unary operators have the highest precedence.</p>

<p>There are eight precedence levels for binary operators.</p>

<pre><code>Precedence     Operator
    8              &amp; / % %% &lt;&lt; &gt;&gt; &amp; &amp;~
    7              + - | ~
    6              'in' 'notin'
    5              == != &lt; &lt;= &gt; &gt;=
    4              &amp;&amp;
    3              ||
    2              .. // If allowed
    1              ? // Ternary expression
</code></pre>

<p>Binary operators of the same precedence associate from left to right. For instance, <code>x / y * z</code> is the same as <code>(x / y) * z</code>.</p>

<h3 id="arithmetic-operators">Arithmetic operators</h3>

<pre><code>+    sum                    integers, floats, complex values, strings
-    difference             integers, floats, complex values
*    product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    modulo dividend        integers
%%   modulo divisor         integers

&amp;    bitwise AND            integers
|    bitwise OR             integers
~    bitwise XOR            integers
&amp;~   bit clear (AND NOT)    integers

&lt;&lt;   left shift             integer &lt;&lt; unsigned integer
&gt;&gt;   right shift            integer &gt;&gt; unsigned integer
</code></pre>

<h4 id="integer-operators">Integer operators:</h4>

<p>For two integer values <code>x</code> and <code>y</code>, the integer quotient <code>q = x / y</code> and remainder <code>r = x % y</code> satisfy the following relationships:</p>

<pre><code>x = q*y + r    and    |r| &lt; |y|
</code></pre>

<p>with <code>x / y</code> truncated towards zero (&rdquo;<a href="https://wikipedia.org/wiki/Modulo_operation">truncated division</a>&rdquo;).</p>

<h2 id="statements">Statements</h2>

<h2 id="built-in-procedures">Built-in procedures</h2>

<h2 id="packages">Packages</h2>

<h2 id="implicit-context-system">Implicit context system</h2>

<h2 id="parametric-polymorphism">Parametric polymorphism</h2>

<h2 id="initialization-and-execution">Initialization and execution</h2>

<h2 id="system-considerations">System considerations</h2>

</article>
</main>
<footer>
&copy; 2007&ndash;2019 Ginger Bill
</footer>
</div>
</body>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
  (function addHeadingLinks(){
    var article = document.getElementsByClassName('article-meta')[0];
    var headings = article.querySelectorAll('h1, h2, h3');
    headings.forEach(function(heading){
      if (heading.id){
        var a = document.createElement('a');
        a.innerHTML = heading.innerHTML;
        a.href = '#'+heading.id;
        heading.innerHTML = '';
        heading.appendChild(a);
      }
    });
  })();
</script>
</html>

